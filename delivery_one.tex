\documentclass{article}

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[portuguese]{babel}

% Set page size and margins
% Replace `letterpaper' with`a4paper' for UK/EU standard size
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}


% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{float}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\title{Criação e Rotulagem de Imagens}
\author{Anderson Garrido Scaioni, Andréia Salmazo Bertasso, 
Johny W. Alves}

\begin{document}
\maketitle

\section{Exercício 6}

\subsection{Enunciado}

Escreva um programa para reproduzir as imagens apresentadas no slide 41. Considere que as imagens têm dimensões: 256x256 com 256 níveis de profundidade. Em seguida, o programa deve ser capaz de apresentar a taxa de amostragem e a profundidade de cada imagem.

\subsection{Código Fonte}

\begin{lstlisting}[language=Python]
# Create images
# in BMP from the struture
# http://www.ue.eti.pg.gda.pl/fpgalab/zadania.spartan3/zad_vga_struktura_pliku_bmp_en.html

# Install package `pip3 install pillow`
from PIL import Image

# Define function to create image
def create_images(name, quantization):
    # Create a new black image with 256x256
    # Mode - P (8-bit pixels, mapped to any other mode using a color palette)
    img = Image.new('P', (256, 256))

    pixels = img.load()  # Create the pixel map
    for i in range(img.size[0]):  # For every pixel:
        for j in range(img.size[1]):
            pixels[i, j] = (quantization(i, j))  # Set the colour accordingly

    img.save('./images/' + name + '.bmp')  # Save file from name


# Create a.bmp image
create_images('a', lambda x, y: 200)


# Create b.bmp image
create_images('b', lambda x, y: 200 if y < 128 else 150)


# Create c.bmp image
def quantization_c(x, y):
    # Coordenates to Boxs
    # (X initial, Y inital, X final, Y final)
    positions_boxs = [
        [45, 55, 85, 75],
        [173, 55, 213, 75],
        [45, 55 + 128, 85, 75 + 128],
        [173, 55 + 128, 213, 75 + 128]
    ]

    def inner_box(a, b):
        for p in positions_boxs:
            if (a > p[0]) and (a <= p[2]) and (b > p[1]) and (b <= p[3]):
                return True
        return False

    if y < 128:
        if inner_box(x, y):
            return 150
        
        return 200

    if inner_box(x, y):
        return 200
    
    return 150


create_images('c', quantization_c)


# Create d.bmp image
def quantization_d(x, y):
    if (x // 128 == 1) and (y // 128 == 1):
        return 225

    if (x // 128 == 1) or (y // 128 == 1):
        return 200

    return 150


create_images('d', quantization_d)


# Create e.bmp image
create_images('e', lambda x, y: 110 + (x // 64 * 10) + (y // 64 * 40))
\end{lstlisting}

\subsection{Explicação}

O programa para geração de imagens foi criado na linguagem Python e utiliza o pacote “Pillow”, foi definida a função {\ttfamily create\textunderscore images(name, quantization):}    que cria a imagem com os parâmetros name (nome da imagem) e quantization (formula de quantificação dos cinzas), nessa função {\ttfamily img = Image.new('P', (256, 256))}   cria a imagem que é de 8 BITS de profundidade com tamanho 256x256 pixels, após a geração da imagem ela é salva em disco com a extensão bmp conforme o seguinte código  {\ttfamily img.save(name + '.bmp')}.

A função é executada 5 vezes, para gerar assim as imagens a.bmp, b.bmp, c.bmp, d.bmp e e.bmp.  

A figura \ref{fig:parte1} descreve o início do meu código fonte especificando o pacote a ser utilizando e a definição da função  create\textunderscore images, na figura \ref{fig:parte2} a função de definição da imagem é executada e as imagens a.bmp e b.bmp são criadas, na figura \ref{fig:parte3} é define o parâmetro de quantization da figura c e a função é executada assim a imagem c.bmp é criada, e por fim a figura \ref{fig:parte4}  define o parâmetro de quantization da figura d após a função de criação de imagem é executada 2 vezes criando as imagens d.bmp e e.bmp.

\section{Exercício 11}

\subsection{Enunciado}

Considere as imagens produzidas no Exercício 6 e implemente um programa para realizar a rotulagem de componentes conexos (cluster/aglomerado). A rotulagem deve ser realizada por meio do “Hoshen–Kopelman algorithm”. O programa deve fornecer o total de componentes conexos e os rótulos atribuídos em cada região da imagem dada como entrada. Use vizinhança-8 como critério. Por fim, considerando a imagem (e) após a rotulagem, o programa deve apresentar as distâncias (DE, D4 e D8) entre os centros de dois componentes conexos (definidos (sorteados) aleatoriamente).

\subsection{Código Fonte}

\begin{lstlisting}[language=Python]
# Install package `pip3 install pillow`
from PIL import Image

import random
import math

n_columns = 256
n_rows = 256
cluster_colors = [
    (214, 39, 40),
    (31, 119, 180),
    (255, 127, 14),
    (44, 160, 44),
    (148, 103, 189),
    (140, 86, 75),
    (227, 119, 194),
    (188, 189, 34),
    (23, 190, 207),
    (214, 39, 40),
    (31, 119, 180),
    (255, 127, 14),
    (44, 160, 44),
    (148, 103, 189),
    (140, 86, 75),
    (227, 119, 194),
    (188, 189, 34),
    (23, 190, 207),
]


def distance_euclidean(first, second):
    fxi, fyi, fxf, fyf = first
    sxi, syi, sxf, syf = second

    x1 = (fxf - fxi) / 2
    y1 = (fyf - fyi) / 2
    x2 = (sxi - sxf) / 2
    y2 = (syi - syf) / 2 

    return str(math.sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2)))


def distance_four(first, second):
    fxi, fyi, fxf, fyf = first
    sxi, syi, sxf, syf = second

    x1 = (fxf - fxi) / 2
    y1 = (fyf - fyi) / 2
    x2 = (sxi - sxf) / 2
    y2 = (syi - syf) / 2

    return str(abs(x1 - x2) + abs(y1 - y2))


def distance_eight(first, second):
    fxi, fyi, fxf, fyf = first
    sxi, syi, sxf, syf = second

    x1 = (fxf - fxi) / 2
    y1 = (fyf - fyi) / 2
    x2 = (sxi - sxf) / 2
    y2 = (syi - syf) / 2

    return str(max(abs(x1 - x2), abs(y1 - y2)))


def find(labels, x):
    y = x

    while (labels[y] != y):
        y = labels[y]

    while (labels[x] != x):
        z = labels[x]
        labels[x] = y
        x = z

    return y


def union(labels, x, y):
    labels[find(labels, x)] = find(labels, y)


def is_connected(first, second):
    fxi, fyi, fxf, fyf = first
    sxi, syi, sxf, syf = second

    return (fxi + 1 == sxf) or (fxf + 1 == sxi) or (fyi + 1 == syf) or (fyf + 1 == syi)


def cluster_image(name):
    largest_label = 0
    total_labels = []
    positions_labels = []
    colors = []
    colors_label = []

    img = Image.open('./images/' + name + ".bmp")
    for i in range(img.size[0]):
        for j in range(img.size[1]):
            gray = img.getpixel((i, j))
            if gray not in colors:
                colors.append(gray)

    for color in colors:
        # Matrix from image with zeros
        label = []
        for x in range(n_columns):
            label.append([])
            for y in range(n_rows):
                label[x].append(0)

        # Array containing integers from 0 to the size of the image
        labels = list(range(n_columns * n_rows + 1))

        for x in range(n_columns):
            for y in range(n_rows):
                if img.getpixel((x, y)) == color:
                    left = 0 if x == 0 else label[x - 1][y]
                    above = 0 if y == 0 else label[x][y - 1]
                    adjacent = 0 if x == 0 and y == 0 else label[x - 1][y - 1]

                    # Neither a label above nor to the left
                    if (left == 0) and (above == 0) and (adjacent == 0):
                        # Make a new, as-yet-unused cluster label
                        largest_label = largest_label + 1
                        label[x][y] = largest_label
                    elif (left != 0) and (above == 0) and (adjacent == 0):  # One neighbor, to the left
                        label[x][y] = find(labels, left)
                    elif (left == 0) and (above != 0) and (adjacent == 0):  # One neighbor, above
                        label[x][y] = find(labels, above)
                    elif (left == 0) and (above == 0) and (adjacent != 0):  # One neighbor, adjacent
                        label[x][y] = find(labels, adjacent)
                    # Neighbors BOTH to the left and above
                    elif (left != 0) and (above != 0) and (adjacent == 0):
                        # Link the left and above clusters
                        union(labels, left, above)
                        label[x][y] = find(labels, left)
                    # Neighbors BOTH to the left and adjacent
                    elif (left != 0) and (above == 0) and (adjacent != 0):
                        # Link the left and adjacent clusters
                        union(labels, left, adjacent)
                        label[x][y] = find(labels, left)
                    # Neighbors BOTH to the above and adjacent and ALL of them
                    else:
                        # Link the above and adjacent clusters
                        union(labels, above, adjacent)
                        label[x][y] = find(labels, above)

        colors_label.append(label)

    # Generate clustered
    img_clustered = Image.new('RGB', (256, 256))
    pixels = img_clustered.load()
    for label in colors_label:
        for i in range(img_clustered.size[0]):
            for j in range(img_clustered.size[1]):
                if (label[i][j] != 0):
                    code = label[i][j]

                    if code not in total_labels:
                        total_labels.append(code)
                        positions_labels.append([j, i, 0, 0])
                    else:
                        index = total_labels.index(code)
                        xi, yi, xf, yf = positions_labels[index]
                        positions_labels[index] = [xi, yi, j, i]

                    pixels[i, j] = cluster_colors[code - 1]

    img_clustered.save('./images/' + name + '_clustered.bmp')

    print('==========================')
    print('Nome: ' + name)
    print('Quantidade de grupos: ' + str(len(total_labels)))
    print('Rótulos dos grupos: ' + ", ".join([str(i) for i in total_labels]))

    if name == 'e':
        code_ref = random.randrange(0, len(total_labels) - 1)
        code_connected = random.randrange(0, len(total_labels) - 1)

        first = positions_labels[code_ref]
        second = positions_labels[code_connected]

        while (not is_connected(first, second)) or (code_ref == code_connected):
            code_connected = random.randrange(0, len(total_labels) - 1)
            second = positions_labels[code_connected]

        print("\nCoordenadas Primeiro: (" + str(first[0]) + ', ' + str(
            first[2]) + ") a (" + str(first[1]) + ', ' + str(first[3]) + ")")
        print("Coordenadas Segundo: (" + str(second[0]) + ', ' + str(
            second[2]) + ") a (" + str(second[1]) + ', ' + str(second[3]) + ")")

        print("Distância Euclidiana: " + distance_euclidean(first, second))
        print("Distância Quadro: " + distance_four(first, second))
        print("Distância Oito: " + distance_eight(first, second))


# Clustering image a.bmp
cluster_image('a')

# Clustering image b.bmp
cluster_image('b')

# Clustering image c.bmp
cluster_image('c')

# Clustering image d.bmp
cluster_image('d')

# Clustering image e.bmp
cluster_image('e')
\end{lstlisting}

\subsection{Explicação}
O algoritmo de rotulagem utilizado foi "Hoshen-Kopelman", para a implementação foi utilizando a linguagem de programação Python e o pacote `"Pillow”, foi definido o numero de linhas e colunas são 256 e que a rotulagem é realizada através das cores, foi definida 4 funções: {\ttfamily find(labels, x):} , {\ttfamily union(labels, x, y):}, {\ttfamily cluster\textunderscore image(labels, label, name):}, {\ttfamily main(name): }. A função {\ttfamily main(name):} , recebe como parâmetro o nome da imagem que foi criada no exercício anterior, assim é executada 6 vezes uma para cada imagem.

\end{document}