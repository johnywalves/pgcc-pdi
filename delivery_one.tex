\documentclass{article}

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[portuguese]{babel}

% Set page size and margins
% Replace `letterpaper' with`a4paper' for UK/EU standard size
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}


% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{float}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\title{Criação e Rotulagem de Imagens}
\author{Anderson Garrido Scaioni, Andréia Salmazo Bertasso, 
Johny W. Alves}

\begin{document}
\maketitle

\section{Exercício 6}

\subsection{Enunciado}

Escreva um programa para reproduzir as imagens apresentadas no slide 41. Considere que as imagens têm dimensões: 256x256 com 256 níveis de profundidade. Em seguida, o programa deve ser capaz de apresentar a taxa de amostragem e a profundidade de cada imagem.

\subsection{Código Fonte}

\begin{lstlisting}[language=Python]
# Create images
# in BMP from the struture
# http://www.ue.eti.pg.gda.pl/fpgalab/zadania.spartan3/zad_vga_struktura_pliku_bmp_en.html

# Install package `pip3 install pillow`
from PIL import Image

# Define function to create image
def create_images(name, quantization):
    # Create a new black image with 256x256
    # Mode - P (8-bit pixels, mapped to any other mode using a color palette)
    img = Image.new('P', (256, 256))

    pixels = img.load()  # Create the pixel map
    for i in range(img.size[0]):  # For every pixel:
        for j in range(img.size[1]):
            pixels[i, j] = (quantization(i, j))  # Set the colour accordingly

    img.save('./images/' + name + '.bmp')  # Save file from name


# Create a.bmp image
create_images('a', lambda x, y: 200)


# Create b.bmp image
create_images('b', lambda x, y: 200 if y < 128 else 150)


# Create c.bmp image
def quantization_c(x, y):
    # Coordenates to Boxs
    # (X initial, Y inital, X final, Y final)
    positions_boxs = [
        [45, 55, 85, 75],
        [173, 55, 213, 75],
        [45, 55 + 128, 85, 75 + 128],
        [173, 55 + 128, 213, 75 + 128]
    ]

    def inner_box(a, b):
        for p in positions_boxs:
            if (a > p[0]) and (a <= p[2]) and (b > p[1]) and (b <= p[3]):
                return True
        return False

    if y < 128:
        if inner_box(x, y):
            return 150
        
        return 200

    if inner_box(x, y):
        return 200
    
    return 150


create_images('c', quantization_c)


# Create d.bmp image
def quantization_d(x, y):
    if (x // 128 == 1) and (y // 128 == 1):
        return 225

    if (x // 128 == 1) or (y // 128 == 1):
        return 200

    return 150


create_images('d', quantization_d)


# Create e.bmp image
create_images('e', lambda x, y: 110 + (x // 64 * 10) + (y // 64 * 40))
\end{lstlisting}

\subsection{Explicação}

O programa para geração de imagens foi criado na linguagem Python e utiliza o pacote “Pillow”, foi definida a função {\ttfamily create\textunderscore images(name, quantization)} que cria a imagem com os parâmetros name (nome da imagem) e quantization (quantificação dos cinzas), nessa função {\ttfamily img = Image.new('P', (256, 256))} a imagem criada é de 8 bits de profundidade com tamanho 256x256 pixels, após a geração da imagem ela é salva em disco na pasta images com a extensão bmp conforme o seguinte código  {\ttfamily  img.save('./images/' + name + '.bmp')}.

A função é executada 5 vezes, para gerar assim as imagens a.bmp, b.bmp, c.bmp, d.bmp e e.bmp na pasta images.  


\section{Exercício 11}

\subsection{Enunciado}

Considere as imagens produzidas no Exercício 6 e implemente um programa para realizar a rotulagem de componentes conexos (cluster/aglomerado). A rotulagem deve ser realizada por meio do “Hoshen–Kopelman algorithm”. O programa deve fornecer o total de componentes conexos e os rótulos atribuídos em cada região da imagem dada como entrada. Use vizinhança-8 como critério. Por fim, considerando a imagem (e) após a rotulagem, o programa deve apresentar as distâncias (DE, D4 e D8) entre os centros de dois componentes conexos (definidos (sorteados) aleatoriamente).

\subsection{Código Fonte}

\begin{lstlisting}[language=Python]
# Install package `pip3 install pillow`
from PIL import Image

import random
import math

n_columns = 256
n_rows = 256
cluster_colors = [
    (214, 39, 40),
    (31, 119, 180),
    (255, 127, 14),
    (44, 160, 44),
    (148, 103, 189),
    (140, 86, 75),
    (227, 119, 194),
    (188, 189, 34),
    (23, 190, 207),
    (214, 39, 40),
    (31, 119, 180),
    (255, 127, 14),
    (44, 160, 44),
    (148, 103, 189),
    (140, 86, 75),
    (227, 119, 194),
    (188, 189, 34),
    (23, 190, 207),
]


def distance_euclidean(first, second):
    (x1, y1) = first
    (x2, y2) = second

    return str(math.sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2)))


def distance_four(first, second):
    (x1, y1) = first
    (x2, y2) = second

    return str(abs(x1 - x2) + abs(y1 - y2))


def distance_eight(first, second):
    (x1, y1) = first
    (x2, y2) = second

    return str(max(abs(x1 - x2), abs(y1 - y2)))


def find(labels, x):
    y = x

    while (labels[y] != y):
        y = labels[y]

    while (labels[x] != x):
        z = labels[x]
        labels[x] = y
        x = z

    return y


def union(labels, x, y):
    labels[find(labels, x)] = find(labels, y)


def is_connected(first, second):
    fxi, fyi, fxf, fyf = first
    sxi, syi, sxf, syf = second

    return (fxi + 1 == sxf) or (fxf + 1 == sxi) or (fyi + 1 == syf) or (fyf + 1 == syi)


def cluster_image(name):
    largest_label = 0
    total_labels = []
    positions_labels = []
    colors = []
    colors_label = []

    img = Image.open('./images/' + name + ".bmp")
    for i in range(img.size[0]):
        for j in range(img.size[1]):
            gray = img.getpixel((i, j))
            if gray not in colors:
                colors.append(gray)

    for color in colors:
        # Matrix from image with zeros
        label = []
        for x in range(n_columns):
            label.append([])
            for y in range(n_rows):
                label[x].append(0)

        # Array containing integers from 0 to the size of the image
        labels = list(range(n_columns * n_rows + 1))

        for x in range(n_columns):
            for y in range(n_rows):
                if img.getpixel((x, y)) == color:
                    left = 0 if x == 0 else label[x - 1][y]
                    above = 0 if y == 0 else label[x][y - 1]
                    adjacent = 0 if x == 0 and y == 0 else label[x - 1][y - 1]

                    # Neither a label above nor to the left
                    if (left == 0) and (above == 0) and (adjacent == 0):
                        # Make a new, as-yet-unused cluster label
                        largest_label = largest_label + 1
                        label[x][y] = largest_label
                    elif (left != 0) and (above == 0) and (adjacent == 0):  # One neighbor, to the left
                        label[x][y] = find(labels, left)
                    elif (left == 0) and (above != 0) and (adjacent == 0):  # One neighbor, above
                        label[x][y] = find(labels, above)
                    elif (left == 0) and (above == 0) and (adjacent != 0):  # One neighbor, adjacent
                        label[x][y] = find(labels, adjacent)
                    # Neighbors BOTH to the left and above
                    elif (left != 0) and (above != 0) and (adjacent == 0):
                        # Link the left and above clusters
                        union(labels, left, above)
                        label[x][y] = find(labels, left)
                    # Neighbors BOTH to the left and adjacent
                    elif (left != 0) and (above == 0) and (adjacent != 0):
                        # Link the left and adjacent clusters
                        union(labels, left, adjacent)
                        label[x][y] = find(labels, left)
                    # Neighbors BOTH to the above and adjacent and ALL of them
                    else:
                        # Link the above and adjacent clusters
                        union(labels, above, adjacent)
                        label[x][y] = find(labels, above)

        colors_label.append(label)

    # Generate clustered
    img_clustered = Image.new('RGB', (256, 256))
    pixels = img_clustered.load()
    for label in colors_label:
        for i in range(img_clustered.size[0]):
            for j in range(img_clustered.size[1]):
                if (label[i][j] != 0):
                    code = label[i][j]

                    if code not in total_labels:
                        total_labels.append(code)
                        positions_labels.append([j, i, 0, 0])
                    else:
                        index = total_labels.index(code)
                        xi, yi, xf, yf = positions_labels[index]
                        positions_labels[index] = [xi, yi, j, i]

                    pixels[i, j] = cluster_colors[code - 1]

    img_clustered.save('./images/' + name + '_clustered.bmp')

    print('==========================')
    print('Nome: ' + name)
    print('Quantidade de grupos: ' + str(len(total_labels)))
    print('Rótulos dos grupos: ' + ", ".join([str(i) for i in total_labels]))

    if name == 'e':
        code_ref = random.randrange(0, len(total_labels) - 1)
        code_connected = random.randrange(0, len(total_labels) - 1)

        first = positions_labels[code_ref]
        second = positions_labels[code_connected]

        while (not is_connected(first, second)) or (code_ref == code_connected):
            code_connected = random.randrange(0, len(total_labels) - 1)
            second = positions_labels[code_connected]

        fxi, fyi, fxf, fyf = first
        sxi, syi, sxf, syf = second

        x1 = (fxf - fxi + 1) / 2 + fxi
        y1 = (fyf - fyi + 1) / 2 + fyi
        x2 = (sxf - sxi + 1) / 2 + sxi
        y2 = (syf - syi + 1) / 2 + syi

        print("\nCoordenadas Primeiro: (" + str(fxi) + ', ' + str(
            fyi) + ") a (" + str(fxf) + ', ' + str(fyf) + ") centro (" + str(x1) + ", " + str(y1) + ")")
        print("Coordenadas Segundo: (" + str(sxi) + ', ' + str(
            syi) + ") a (" + str(sxf) + ', ' + str(syf) + ") centro (" + str(x2) + ", " + str(y2) + ")")

        print("Distância Euclidiana: " + distance_euclidean((x1, y1), (x2, y2)))
        print("Distância Quadro: " + distance_four((x1, y1), (x2, y2)))
        print("Distância Oito: " + distance_eight((x1, y1), (x2, y2)))


# Clustering image a.bmp
cluster_image('a')

# Clustering image b.bmp
cluster_image('b')

# Clustering image c.bmp
cluster_image('c')

# Clustering image d.bmp
cluster_image('d')

# Clustering image e.bmp
cluster_image('e')
\end{lstlisting}

\subsection{Explicação}

\begin{flushleft}
A implementação do algortimo para clursterização tem como base o algoritmo de rotulagem "Hoshen-Kopelman", adaptado para utilizar vizinhaça 8 e agrupar pela quantização de cinza, a linguagem de programação é Python juntamente com o pacote "Pillow".
\end{flushleft}

\begin{flushleft}
Definido o número de linhas e colunas (256x256) vindo das imagens e um vetor com as possíveis cores a rotulagem.
\end{flushleft}

\begin{flushleft}
Três funções para calcular a distância foram implementadas:
\end{flushleft}

\begin{itemize}
    \item {\ttfamily distance\textunderscore euclidean(first, second)};
    \item {\ttfamily distance\textunderscore four(first, second)};
    \item {\ttfamily distance\textunderscore eight(first, second)}.
\end{itemize}

\begin{flushleft}
A função {\ttfamily cluster\textunderscore image(name)} realiza a rotulagem através de cores e quando executada utiliza as funções:
\end{flushleft}

\begin{itemize}
   \item {\ttfamily find(labels, x)};
   \item {\ttfamily union(labels, x, y)}.
 \end{itemize}

\begin{flushleft}
A imagem clursterizada é salva na pasta images com o nome da imagem original + "\textunderscore clustered.bmp", após a imagem ser salva é exibido nome da imagem original, quantidade de grupos e rótulos dos grupos. 
\end{flushleft}

\begin{flushleft}
Se a imagem a ser clursterizada for a imagem "e.bmp" é calculada as distância euclidiana, distância quatro (\textit{city-block}) e distância oito (\textit{chessboard}) de dois aglomerados conexos, selecionados aleatoriamente e verificados pela função {\ttfamily is\textunderscore connected(first, second)}
\end{flushleft}

\begin{flushleft}
A função {\ttfamily cluster\textunderscore image} é executada 6 vezes uma para cada imagem gerada no exercício anterior.
\end{flushleft}

\begin{lstlisting}[language=Bash]
==========================
Nome: a
Quantidade de grupos: 1
Rotulos dos grupos: 1
==========================
Nome: b
Quantidade de grupos: 2
Rotulos dos grupos: 1, 2
==========================
Nome: c
Quantidade de grupos: 6
Rotulos dos grupos: 1, 2, 3, 4, 5, 6
==========================
Nome: d
Quantidade de grupos: 3
Rotulos dos grupos: 1, 2, 3
==========================
Nome: e
Quantidade de grupos: 16
Rotulos dos grupos: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16

Coordenadas Primeiro: (128, 192) a (191, 255) centro (160.0, 224.0)
Coordenadas Segundo: (192, 64) a (255, 127) centro (224.0, 96.0)
Distancia Euclidiana: 143.10835055998655
Distancia Quadro: 192.0
Distancia Oito: 128.0
\end{lstlisting}

\end{document}